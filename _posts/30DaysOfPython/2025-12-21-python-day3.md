---
layout: post
title: Learning Python Operators - From Simple Math to Bitwise Logic
description: >-
  On Day 3 of my Python journey, I dive into operators — the building blocks behind conditions, decisions, and data manipulation. This post captures my learning process, the mistakes I made, and the concepts that finally clicked.
author: Sheikh Hussain
date: 2025-12-21 17:40:00 +0000
categories: [Python, Courses]
tags: [python, programming, course, 30days, day3, operators]
pin: false
math: false
mermaid: false
image:
  path: 012026/python_day3.jpg
  alt: Image from Pexels - Python Programming
  #lqip: data:image/...           # Add the low-quality image placeholder (base64) if needed
render_with_liquid: false
media_subpath: /assets/img/posts/
---

Python has been relatively easy to _understand_ so far, but I’ve noticed that my biggest hurdle is actually **writing code**, not reading it. I think this comes from spending more time learning _about_ Python than actually practising it — a polite way of saying procrastination.

That said, I still believe good preparation leads to better code later. Taking the time to really understand concepts has already saved me confusion further down the line.

On Day 3 of the _30 Days of Python_ course, the focus is on **operators**[^f1]. While many of these were familiar from basic maths, some — especially **bitwise operators** — were something I completely missed the first few times around. This time, I wanted to slow things down, understand _why_ they work the way they do, and document what I learn along the way.

---

## What Are Python Operators?

Python operators are symbols that allow us to **perform actions on data**. These actions include:

- Performing mathematical calculations
- Assigning or updating values in variables
- Comparing values
- Making decisions using conditions
- Working directly with binary (bit-level) data

In simple terms, operators help Python decide **what to do next** based on the data we give it.

For example, imagine we have an `age` variable:

```python
age = 20
age += 1
print(age)  # 21
```

Here, the `+=` operator updates the value stored in `age`. This was one of the first moments where it clicked for me that operators don’t just _check_ values — they often **change them**.

They can also be used for calculations:

```python
num1 = 3
num2 = 7

ans = num1 + num2
print(ans)  # 10
```

As I progress through the course, I notice that operators are rarely used in isolation. Most real logic comes from **combining multiple operators together**, a concept known as _compounding_, which is where Python code begins to feel more practical and expressive.

## Arithmetic Operators

I decided to start with arithmetic operators because they were the first ones I encountered while learning about variables. They also feel the most intuitive, since they behave just like everyday maths.

| Operator | Name                         | Example  |
| -------- | ---------------------------- | -------- |
| `+`      | Addition                     | `5 + 3`  |
| `-`      | Subtraction                  | `5 - 3`  |
| `*`      | Multiplication               | `5 * 3`  |
| `/`      | Division                     | `6 / 2`  |
| `%`      | Modulus (remainder)          | `7 % 2`  |
| `//`     | Floor Division (rounds down) | `7 // 2` |
| `**`     | Exponentiation (power)       | `2 ** 3` |

_Table source: [30 Days of Python - Day 3](https://github.com/Asabeneh/30-Days-Of-Python/blob/master/03_Day_Operators/03_operators.md)_

These operators form the backbone of most calculations you’ll do in Python.

**Examples**:

```python
num1 = 2
num2 = 6

result1 = num1 + num2   # Addition → 8
result2 = num2 - num1   # Subtraction → 4
result3 = num1 * num2   # Multiplication → 12
result4 = num2 / num1   # Division → 3.0
result5 = num2 % num1   # Modulus → 0
result6 = num1 ** num2  # Exponentiation → 64
result7 = num2 // num1  # Floor division → 3
```

These operators are simple, but they appear everywhere — from counters and scores to complex algorithms.

## Assignment Operators

Assignment operators are used to **store** or **update values** in variables.

The most basic one is `=`:

```python
x = 10
```

However, Python also provides _compound assignment operators_, which combine both arithmetic and assignment operators into a single step. These felt awkward at first, especially because I kept wanting to put the `=` first — but once I got used to them, they actually made my code cleaner.

| Operator | Name                    | Example   | Same As      |
| -------- | ----------------------- | --------- | ------------ |
| `=`      | Assignment              | `x = 5`   | `x = 5`      |
| `+=`     | Add and Assign          | `x += 2`  | `x = x + 2`  |
| `-=`     | Subtract and Assign     | `x -= 2`  | `x = x - 2`  |
| `*=`     | Multiply and Assign     | `x *= 2`  | `x = x * 2`  |
| `/=`     | Divide and Assign       | `x /= 2`  | `x = x / 2`  |
| `%=`     | Modulus and Assign      | `x %= 2`  | `x = x % 2`  |
| `//=`    | Floor Divide and Assign | `x //= 2` | `x = x // 2` |
| `**=`    | Exponent and Assign     | `x **= 2` | `x = x ** 2` |

_Table source: [30 Days of Python - Day 3](https://github.com/Asabeneh/30-Days-Of-Python/blob/master/03_Day_Operators/03_operators.md)_

Once I started seeing these as shortcuts rather than new syntax, they became much easier to remember.

## Logical Operators

Logical operators allow us to **combine conditions** and make more precise decisions.

| Operator | Name        | Example             |
| -------- | ----------- | ------------------- |
| `and`    | Logical AND | `x > 5 and x < 10`  |
| `or`     | Logical OR  | `x == 5 or x == 10` |
| `not`    | Logical NOT | `not x == 5`        |

_Table source: [30 Days of Python - Day 3](https://github.com/Asabeneh/30-Days-Of-Python/blob/master/03_Day_Operators/03_operators.md)_

**Example**:

```python
day = "Saturday"

if day == "Saturday" or day == "Sunday":
    print("It's the weekend!")
```

This was one of the first examples where Python logic started to feel _real_ to me — it closely mirrors how we think and reason in everyday situations.

## Comparison Operators

Comparison operators are used to **compare values** and always return a Boolean (`True` or `False`).

| Operator | Name                     | Example  |
| -------- | ------------------------ | -------- |
| `==`     | Equal to                 | `x == 5` |
| `!=`     | Not equal to             | `x != 5` |
| `>`      | Greater than             | `x > 5`  |
| `<`      | Less than                | `x < 5`  |
| `>=`     | Greater than or equal to | `x >= 5` |
| `<=`     | Less than or equal to    | `x <= 5` |

_Table source: [30 Days of Python - Day 3](https://github.com/Asabeneh/30-Days-Of-Python/blob/master/03_Day_Operators/03_operators.md)_

**Example**:

```python
var_a = 5
var_b = 10

if var_a > var_b:
    print(f"{var_a} is greater!")
else:
    print(f"{var_b} is greater!")

# Output:
'10 is greater!'

print(var_a > var_b) # False
```

These operators are essential for branching logic and decision-making.

From that example, we are able to see how we can create conditions using IF Statements which is something that I'll be learning about in **Day 9 - Conditionals**.

## Other Operators

While reviewing the course content and external sources, I came across operator types that weren’t heavily emphasised in the exercises. Even though they’re more niche, I wanted to include them here so my notes stay complete[^f2].

> This is a complete guide to use or resource I would read over - [Python Identity Operators](https://www.w3schools.com/python/python_operators.asp)
> {: .prompt-tip}

### Bitwise (Binary) Assignment Operators

This was the section I had **never learned** before.

Bitwise operators work directly with **binary representations** of numbers. They’re not something I expect to use daily right now, but understanding them early makes them far less intimidating later.

**Bitwise AND (`&=`)**:

```python
a = 5  # 0101
b = 3  # 0011

a &= b
print(a)  # 1 (0001)
```

Only bits that are `1` in **both numbers** remain `1`.

**Bitwise OR (`|=`)**:

```python
a = 5  # 0101
b = 3  # 0011

b |= a
print(b)  # 7 (0111)
```

If **either bit** is `1`, the result is `1`.

**Bitwise XOR (`^=`)**:

```python
a = 5  # 0101
b = 3  # 0011

b ^= a
print(b)  # 6 (0110)
```

**Different** bits → `1`, same bits → `0`.

**Right Bitwise Shift (`>>=`)**:

```python
a = 5  # 0101
a >>= 2
print(a)  # 1 (0001)
```

Shifts bits to the **right**, discarding bits and reducing the number.

**Left Bitwise Shift (`<<=`)**:

```python
a = 5  # 0101
a <<= 2
print(a)  # 20 (10100)
```

Shifts bits to the **left**, adding `0`'s on the right and increasing the number.

### Identity Operators

Identity operators look similar to comparison operators, but instead of comparing values, they compare memory locations.

| **Operator** | **Description**                                                          |
| ------------ | ------------------------------------------------------------------------ |
| `is`         | Returns `True` if both variables refer to the same **object**            |
| `is not`     | Returns `True` if both variables do **not** refer to the same **object** |

_Table source: [Identity Operators](https://www.w3schools.com/python/trypython.asp?filename=demo_oper_identity_example)_

Think of these as checking whether two variables point to the **exact same** thing, not just equal-looking values.

This example has been taken from W3 Schools[^f3].

```python
x = ["apple", "banana"]
y = ["apple", "banana"]
z = x

print(x is z) # True
print(x is y) # False
print(x == y) # True
```

> **Update**: I have recently learnt about **constant** and **runtime** sequences which explain that any sequential data, like strings, created _before_ runtime get stored in the same memory location for as long as the data inside are identical. Therefore, if you where to use the identity operator on these variables it would bring back a `True` statement.
> {: .prompt-tip}

_Example:_

```python
a = "Hello"
b = "Hel" + "lo"

print(a is b) # True
```

### Membership Operators

Membership operators check whether a value **exists within** another object, such as a list or a string.

| **Operator** | **Description**                                                                        |
| ------------ | -------------------------------------------------------------------------------------- |
| `in`         | Returns `True` if a sequence with the specified value is **present** in the object     |
| `not in`     | Returns `True` if a sequence with the specified value is **not present** in the object |

_Table source: [Membership Operators](https://www.w3schools.com/python/python_operators_membership.asp)_

**Example (Using a List)**:

```python
fruits = ["apple", "banana", "cherry"]

print("banana" in fruits) # True
print("pineapple" not in fruits) # True
```

**Example (Using a String)**:

```python
text = "Membership Operator"

print("M" in text) # True
print("S" in text) # False (case sensitive)
print("Operator" in text) # True
print("operator" in text) # False (case sensitive)
print("z" not in text) # True
```

## Footnote:

[^f1]: [30 Days of Python - Day 3](https://github.com/Asabeneh/30-Days-Of-Python/blob/master/03_Day_Operators/03_operators.md)
[^f2]: [W3 Schools - Python Operators](https://www.w3schools.com/python/python_operators.asp)
[^f3]: [W3 Schools - Identity Operators](https://www.w3schools.com/python/trypython.asp?filename=demo_oper_identity_example)
[^f4]: [W3 Schools - Membership Operators](https://www.w3schools.com/python/python_operators_membership.asp)
