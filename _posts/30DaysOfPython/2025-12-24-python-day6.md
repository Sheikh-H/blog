---
layout: post
title: Tuples - Why Are Tuples Different From Lists, What Can and Can't They Do?
description: >-
  Tuples are lists, but have some limitations. Using them to store and reference information is typically what we find tuples used for. Nonetheless, in Day 5 of the 30 Days of Python Course by Asabeneh. I now retain my knowledge on tuples.
author: Sheikh Hussain
date: 2025-12-24 20:00:00 +0000
categories: [Python, Course, 30 Day of Python]
tags: [python, programming, course, 30days, day6]
pin: false
math: false
mermaid: false
image:
  path: 012026/python_day6.jpg
  alt: Image from Pexels - Python Programming
render_with_liquid: false
media_subpath: /assets/img/posts/
---

So far, we've explored what a _collection data type_ is and how we can use them with a traditional list. Now, I need to be able to understand how **tuples** differ. Before I begin, I should make mention that a tuple is ordered[^f1] and immutable; once you create a tuple you cannot add, insert, remove, or edit data.

To me, the overall impression I gain about tuples is that it's used to store **fixed data** or information that doesn't require any change like, Days of the week, Months, Status Codes, Configuration Values, etc.

With that said... I'll now start to uncover all the functions of tuples.

## Creating a Tuple

Similar to creating lists, we'd use the same function to create a empty list, except now we'll use either `()` or `tuple()`.

```python
var_a = () # This creates an empty tuple
var_b = tuple() # This also creates one using a function.
```

I've explained that with tuples being immutable, we have many functions that we aren't able to do. So, for the latter part of this post I'll be writing functions that are used to access or check the information displayed within a tuple.

<!-- prettier-ignore -->
> Tip: You _can_ change a tuple to another collection data type like list, then modify it, and then change the new list with modified items in to a tuple.
{: .prompt-tip}

## Accessing Items in a Tuple

To access items in a Tuple we would also use indexing to bring back values.

```python
lst = ("Item1", "Item2", "Item3")
print(lst[0]) # Item1
print(lst[-1]) # Item3
```

We can also use the `len()` function to find the total number of items.

```python
lst = ("Item1", "Item2", "Item3")
print(len(lst)) # 3
```

By this point, you might be thinking about indexing and if `len()` brings the total number of items from a list, then how would we use that information?

To answer that, I often tell myself to relate it to indexing values. If all the items have an index number that starts from 0, then surely the length of the list would match the index + 1. So if I were to create a function that calculates the entire list and then takes 1 away from the total, I can now use that to reference the last element on the list.

This is especially useful when dealing with tuples because mostly you'll be using functions to access different items in the list.

```python
lst = ("Item1", "Item2", "Item3")
#         0        1        2     Index Ref
#         1        2        3     Length of tuple

last_index = len(lst) - 1 # 2

print(lst[last_index]) # Item3
```

## Slicing Tuples

We can also use the slicing method on tuples, just keep in mind that it produces a new tuple and doesn't mutate or change the old list.

```python
lst = ("Item1", "Item2", "Item3")
#         1        1

print(lst[0:2:1]) # ["Item1", "Item2"]
```

<!-- prettier-ignore -->
> I've just realised that the method used to slice should really be referred to as [start:stop:step] not "skip" as it selects the data it lands on.
{: .prompt-tip}

## Changing Collection Data Types

In an earlier post on [List Data Types](https://sheikh-h.github.io/Blog/posts/python-day5/), I briefly explained over how we are able to change one collection data type to another. I thought I would include it in each of the posts regarding collection data types as it is often overlooked.

```python
lst = ("Item1", "Item2", "Item3")
lst = list(lst)
print(lst) # ["Item1", "Item2", "Item3"]
```

## Checking an Item in a Tuple

```python
var_a = ("item1", "Item2")
print("item1" in var_a) # True
var_b = "Item2" in var_a
print(var_b) # True
```

We already know that we can use the membership operators to provide us with a boolean result based on the criteria we give it, this is here to serve as an example.

## Joining Tuples

```python
lst1 = ("Item1", "Item2") # Tuple
lst2 = ("Item3", "Item4") + lst1 # Concatenating tuples

print(lst2) # ("Item3", "Item4", "Item1", "Item2") # printed in the order it is inserted.
```

<!-- prettier-ignore -->
> **Tip**: I have also learnt that you can join different list types together but must first change or specify the list to being the type you require.
{: .prompt-tip}

```python
lst1 = ["Item1"]
lst2 = ("Item2")

lst = tuple(lst1) + lst2

print(lst) # ("Item1", "Item2")
```

## Deleting Tuples

Being immutable means that you can't change the information inside the list; however you are able to delete the complete list at any point in your program.

```python
lst = ("Item1", "Item2", "Item3")
del lst

print(lst) # error
```

## Summary

I wanted to avoid trying to repeat some of the functions mentioned as of course, if we look at collection data types holistically, several of the functions are apparent in each type. The problem we face here is that each list type is has it's own core functions that make it differ from one another.

That analogy should explain that while the functions you can perform in each data set could look similar, we just need to keep in mind that there could be some differences in the output or how the function is performed.

## Footnote:

[^f1]: [List Data Types](https://sheikh-h.github.io/Blog/posts/python-day5/)
